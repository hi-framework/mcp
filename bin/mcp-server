#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * MCP Server - Model Context Protocol Server for PHP
 *
 * Serves pre-generated documentation to AI assistants like Claude Code
 *
 * Usage:
 *   ./vendor/bin/mcp-server [--mcp-dir=path]
 *
 * Claude Code integration:
 *   claude mcp add my-project ./vendor/bin/mcp-server --mcp-dir=.mcp
 */

// Find autoloader
$autoloadPaths = [
    __DIR__ . '/../../../autoload.php',      // When installed as dependency
    __DIR__ . '/../vendor/autoload.php',     // When running from package root
];

$autoloaderFound = false;
foreach ($autoloadPaths as $autoloadPath) {
    if (\file_exists($autoloadPath)) {
        require_once $autoloadPath;
        $autoloaderFound = true;
        break;
    }
}

if (! $autoloaderFound) {
    \fwrite(\STDERR, "Error: Could not find composer autoloader.\n");
    \fwrite(\STDERR, "Please run 'composer install' first.\n");
    exit(1);
}

use Hi\MCP\Server\DocumentationReader;
use Hi\MCP\Server\McpServer;
use Hi\MCP\Server\Transport\StdioTransport;
use Hi\MCP\Runtime\SignalHandler;

// Parse command line arguments
$options = \getopt('', ['mcp-dir:', 'help', 'version']);

if (isset($options['version'])) {
    echo "MCP Server v2.0.0\n";
    echo "Model Context Protocol Server for PHP\n";
    exit(0);
}

if (isset($options['help'])) {
    echo "MCP Server - Model Context Protocol Server for PHP\n";
    echo "\n";
    echo "Usage: mcp-server [options]\n";
    echo "\n";
    echo "Options:\n";
    echo "  --mcp-dir=PATH   Directory containing generated documentation (default: .mcp)\n";
    echo "  --version        Show version information\n";
    echo "  --help           Show this help message\n";
    echo "\n";
    echo "Setup:\n";
    echo "  1. Generate documentation first:\n";
    echo "     mcp-generate --src=vendor/hi/framework/src --docs=vendor/hi/framework/docs --output=.mcp\n";
    echo "\n";
    echo "  2. Start the server:\n";
    echo "     mcp-server --mcp-dir=.mcp\n";
    echo "\n";
    echo "Claude Code integration:\n";
    echo "  claude mcp add hi-framework ./vendor/bin/mcp-server --mcp-dir=.mcp\n";
    echo "\n";
    exit(0);
}

// Determine project root directory
$rootDir = \getcwd();

// Configuration parameters
$mcpDir = $options['mcp-dir'] ?? '.mcp';

// Convert to absolute paths
if (! \str_starts_with($mcpDir, '/')) {
    $mcpDir = $rootDir . '/' . $mcpDir;
}

// Validate MCP directory
if (! \is_dir($mcpDir)) {
    \fwrite(\STDERR, "Error: MCP documentation directory not found: {$mcpDir}\n");
    \fwrite(\STDERR, "\n");
    \fwrite(\STDERR, "Please generate documentation first:\n");
    \fwrite(\STDERR, "  mcp-generate --src=vendor/hi/framework/src --docs=vendor/hi/framework/docs --output=.mcp\n");
    exit(1);
}

// Check for manifest file
$manifestPath = $mcpDir . '/manifest.json';
if (! \file_exists($manifestPath)) {
    \fwrite(\STDERR, "Error: Manifest file not found: {$manifestPath}\n");
    \fwrite(\STDERR, "\n");
    \fwrite(\STDERR, "Please regenerate documentation:\n");
    \fwrite(\STDERR, "  mcp-generate --src=vendor/hi/framework/src --docs=vendor/hi/framework/docs --output=.mcp\n");
    exit(1);
}

// Create and start server
try {
    $docReader = new DocumentationReader($mcpDir);
    $transport = new StdioTransport();

    $frameworkInfo = $docReader->getFrameworkInfo();

    $server = new McpServer(
        transport: $transport,
        docReader: $docReader,
        serverName: "{$frameworkInfo['name']} MCP Server",
        serverVersion: '2.0.0',
    );

    // Register signal handling for graceful shutdown
    $signalHandler = new SignalHandler();

    $shutdownHandler = static function (int $signal, int $timestamp) use ($server, $transport): void {
        unset($timestamp);
        $transport->log("Received signal {$signal}, stopping server...");
        $server->stop();
    };

    $signalHandler->register(\SIGINT, $shutdownHandler);
    $signalHandler->register(\SIGTERM, $shutdownHandler);
    $signalHandler->register(\SIGHUP, $shutdownHandler);

    // Start main loop
    $server->run();

    // Cleanup
    $signalHandler->cleanup();

    exit(0);
} catch (\Throwable $e) {
    \fwrite(\STDERR, "Fatal error: {$e->getMessage()}\n");
    \fwrite(\STDERR, "Stack trace:\n{$e->getTraceAsString()}\n");
    exit(1);
}
